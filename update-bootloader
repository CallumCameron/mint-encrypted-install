#!/bin/bash

SETTINGS_DIR="${HOME}/.mint-encrypted-install"

function load-setting() {
    # Returns empty string if file does not exist
    cat "${SETTINGS_DIR}/${1}" 2>/dev/null
}

function save-setting() {
    mkdir -p "${SETTINGS_DIR}" && # shellcheck: disable=SC2015
    echo "${2}" > "${SETTINGS_DIR}/${1}" || fail
}

function enter-to-continue() {
    echo &&
    read -r -p "Press ENTER to continue..." &&
    echo &&
    echo
}

function yn-y() {
    # Y is the default
    local REPLY
    read -p "${1} [Y/n] " -r
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        return 1
    else
        return 0
    fi
}

function yn-n() {
    # N is the default
    local REPLY
    read -p "${1} [y/N] " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

function read-existing-path() {
    read -r -p "${1}: " name || fail
    if [ -z "${name}" ] || [ ! -e "${name}" ]; then
        echo "That file doesn't exist!" 1>&2
        exit 1
    else
        echo "${name}"
    fi
}

function fail() {
    echo -e "\e[31mSomething went wrong!\e[0m"
    exit 1
}


cat <<EOF
This script will update the initramfs and bootloader, from inside a running
Mint installation previously set up using mint-encrypted-install.
EOF

if ! yn-n "Continue?"; then
    exit 0
fi


# Not completely foolproof, but should do the job...
if ! lsb_release -a 2>/dev/null | grep 'tara\|tessa' &>/dev/null || type ubiquity &>/dev/null; then
cat <<EOF


You are not running on an installed Linux Mint 19 or 19.1 system. Cannot go any
further.
EOF
    exit 1
fi

if [ ! -e '/sys/firmware/efi' ]; then
    echo 'Your firmware is BIOS. This script only supports UEFI. Cannot go any further.'
    exit 1
fi


# Convenient place to get the sudo password, before asking for settings
sudo true || fail
echo


# Load settings
BOOT_DEVICE="$(load-setting boot-device)"
UEFI_PARTITION_NUM="$(load-setting uefi-partition-num)"


# Check settings
if [ ! -z "${BOOT_DEVICE}" ]; then
    echo 'Block devices:'
    lsblk
    cat <<EOF

Settings saved from last run:
    Bootloader device: ${BOOT_DEVICE}
EOF
    if ! yn-y '    Is this correct?'; then
        BOOT_DEVICE=''
    fi
    echo
fi

if [ ! -z "${UEFI_PARTITION_NUM}" ]; then
    cat <<EOF
    UEFI partition number on boot device: ${UEFI_PARTITION_NUM}
EOF
    if ! yn-y '    Is this correct?'; then
        UEFI_PARTITION_NUM=''
    fi
    echo
fi


# Get any missing settings
if [ -z "${BOOT_DEVICE}" ]; then
    echo 'Block devices:'
    lsblk
    echo
    BOOT_DEVICE="$(read-existing-path "Enter the device on which the bootloader is installed; typically something like /dev/sda or /dev/sdb for hard drives, or /dev/nvme0n1 or /dev/nvme0n2 for NVME SSDs")"
    if [ -z "${BOOT_DEVICE}" ]; then
        fail
    fi
    save-setting boot-device "${BOOT_DEVICE}"
    echo
fi

if [ -z "${UEFI_PARTITION_NUM}" ]; then
    echo 'Block devices:'
    lsblk
    echo
    read -r -p "Enter the number of the UEFI boot partition, e.g. if the partition is /dev/sda1 on a hard drive, enter 1, or /dev/nvme0n1p2 on an NVME SSD, enter 2: " UEFI_PARTITION_NUM || fail
    if [ -z "${UEFI_PARTITION_NUM}" ]; then
        echo 'Invalid partition number'
        fail
    fi
    save-setting uefi-partition-num "${UEFI_PARTITION_NUM}"
    echo
fi


# Now actually start the update
sudo locale-gen --purge --no-archive &&
sudo update-initramfs -u &&
sudo update-grub && # shellcheck: disable=SC2015
sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Mint --boot-directory=/boot --modules="all_video boot btrfs cat chain configfile crypto cryptodisk disk diskfilter echo efifwsetup efinet ext2 fat font gettext gcry_arcfour gcry_blowfish gcry_camellia gcry_cast5 gcry_crc gcry_des gcry_dsa gcry_idea gcry_md4 gcry_md5 gcry_rfc2268 gcry_rijndael gcry_rmd160 gcry_rsa gcry_seed gcry_serpent gcry_sha1 gcry_sha256 gcry_sha512 gcry_tiger gcry_twofish gcry_whirlpool gfxmenu gfxterm gfxterm_background gzio halt hfsplus iso9660 jpeg keystatus loadenv loopback linux linuxefi lsefi lsefimmap lsefisystab lssal luks lvm mdraid09 mdraid1x memdisk minicmd normal part_apple part_msdos part_gpt password_pbkdf2 png raid5rec raid6rec reboot search search_fs_uuid search_fs_file search_label sleep squash4 test true verify video zfs zfscrypt zfsinfo" --recheck || fail

# Print out the boot order
sudo efibootmgr

cat <<EOF

Finished - you may want to change the boot order using 'efibootmgr -o',
and remember to run this script again if you update grub or the kernel.
EOF
